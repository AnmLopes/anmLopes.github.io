<section id="technical-skills">
  <div class="technical-skills card" data-aos="fade-up">
    <h2 class="section-title">Technical Skills</h2>
    
    <h3>Computer Science Theory and Formal Modelling</h3>
    <ul>
      <li>Data and system modelling using logic and set theory.</li>
      <li>Countable and uncountable sets, Cantor's diagonal argument.</li>
      <li>Deterministic (DFA) and non-deterministic finite automata (NFA).</li>
      <li>Regular expressions and context-free grammars.</li>
      <li>Building LL and LR parsers.</li>
      <li>Computability and complexity concepts: P, NP classes, and undecidable problems.</li>
      <li>Turing machines, Church-Turing thesis, and computational universality.</li>
      <li>Difference between function and algorithm, levels of interpretation of abstract machines.</li>
    </ul>

    <h3>Computational Logic and Discrete Mathematics</h3>
    <ul>
      <li>Propositional logic: syntax, semantics, truth tables, Boolean algebra.</li>
      <li>First-order logic: terms, quantifiers, valuation, and interpretation structure.</li>
      <li>Natural Deduction: introduction and elimination rules.</li>
      <li>Resolution and proof algorithms: clausal form, Skolemization, unification.</li>
      <li>Mathematical induction and structured logical reasoning.</li>
    </ul>

    <h3>Digital Logic and Computational Systems</h3>
    <ul>
      <li>Boolean algebra, truth tables, and logical function simplification using Karnaugh maps.</li>
      <li>Design and implementation of combinational circuits: encoders, decoders, multiplexers, demultiplexers, and binary arithmetic circuits.</li>
      <li>Implementation of sequential circuits: registers, counters, and state machines (Moore and Mealy).</li>
      <li>Digital memories: operation of RAM, ROM, PROM, EPROM, and EEPROM.</li>
      <li>Introduction to microprocessor architecture and decomposition into control and data parts.</li>
      <li>Assembly programming and translation between Assembly and C.</li>
      <li>Processor architecture: single-cycle operation, pipelines, and optimizations in microprocessors.</li>
      <li>Cache memory structures and introduction to virtual memory.</li>
      <li>Low-level interface for input/output devices.</li>
      <li>Compilation, linking, assembly, and loading of programs.</li>
    </ul>

    <h3>Operating Systems and Concurrent Programming</h3>
    <ul>
      <li>Process management: creation, scheduling, and synchronization of processes and threads.</li>
      <li>Concurrent programming: use of the pthreads API for thread management.</li>
      <li>Memory management: paging, segmentation, and page replacement algorithms.</li>
      <li>File systems: structure, operations, and data consistency.</li>
      <li>Input/Output and Device Drivers: abstraction and operation.</li>
      <li>Virtualization: concepts of virtual machines and containers (e.g., Docker).</li>
      <li>Development of programs interacting with system calls in Unix/Linux environments.</li>
    </ul>

    <h3>Object-Oriented Programming (OOP) and Software Engineering</h3>
    <ul>
      <li>Fundamental concepts of Object-Oriented Programming (OOP): classes, interfaces, polymorphism, and inheritance.</li>
      <li>Design and development of modular and reusable applications.</li>
      <li>Generic programming and efficient use of collections (lists, arrays, dictionaries, sets).</li>
      <li>Exception handling and debugging techniques.</li>
      <li>Software testing and verification, including regression testing and code validation.</li>
      <li>Use of APIs and class libraries for manipulating collections and building graphical user interfaces.</li>
    </ul>

    <h3>Algorithms and Data Structures</h3>
    <ul>
      <li>Algorithm analysis: asymptotic complexity, best, worst, and average-case analysis.</li>
      <li>Recursive programming: divide and conquer techniques and memoization.</li>
      <li>Abstract data types: stacks (LIFO), queues (FIFO), linked lists, dictionaries, priority queues.</li>
      <li>Advanced data structures: hash tables, binary trees, AVL trees, heaps.</li>
      <li>Sorting algorithms: insertion sort, selection sort, bubble sort, quicksort, mergesort, heapsort, and bucket sort.</li>
    </ul>

    <h3>Programming Languages and Paradigms</h3>
    <ul>
      <li>Study and comparison of modern programming languages: Caml, C, JavaScript, Java.</li>
      <li>Understanding of execution environments: interpretation, compilation, virtual machines, and execution models.</li>
      <li>Functional and procedural languages: usage of OCaml and C, focusing on types, verification and inference, polymorphism, and static typing.</li>
      <li>Object-based languages: analysis of JavaScript and Java: classes, prototypes, inheritance, and subtyping.</li>
      <li>Scripting and Domain-Specific Languages: JavaScript and Bash.</li>
      <li>Programming paradigms: inductive programming in OCaml, pointer manipulation in C, modeling in JavaScript, and introduction to client-side web programming.</li>
      <li>Introduction to web programming: HTTP protocols, forms, AJAX, and client-server event models.</li>
      <li>Choosing the right programming language: factors and scenarios to consider.</li>
    </ul>

    <h3>Databases</h3>
    <ul>
      <li>Data models: Entity-Relationship (ER) and Relational models, with some notions of the object-relational model.</li>
      <li>Relational algebra: formal language for database manipulation.</li>
      <li>SQL fundamentals: creation and manipulation of databases with SQL, both for data definition and data manipulation.</li>
      <li>Database normalization: functional and multivalued dependencies, normal forms (3rd, 4th, and Boyce-Codd).</li>
      <li>Data modeling in XML and manipulation mechanisms.</li>
      <li>Integrity and transactions: referential integrity, assertions and triggers, security and authorizations.</li>
      <li>Database interaction: usage of Embedded SQL, ODBC, JDBC.</li>
      <li>Interface development: creating interfaces for data manipulation.</li>
      <li>Problem modeling in ER and conversion to relational model.</li>
    </ul>

    <h3>Computer Graphics and Interfaces</h3>
    <ul>
      <li>Graphics pipeline: description of the graphics process, from modeling to visualization.</li>
      <li>Modeling with polygons and vertex attributes: basic modeling techniques and manipulation of graphics.</li>
      <li>Lighting and shadows: lighting models and shading techniques for rasterized graphics.</li>
      <li>Building graphical user interfaces: principles and techniques of user interface design.</li>
      <li>Graphic programming: creating interactive graphical applications using modern APIs like WebGL.</li>
      <li>Abstraction and efficiency: translating graphic design principles into efficient implementations.</li>
      <li>Graphical Interface Development and Solution Evaluation: analyzing efficiency and experimentation in graphical solutions.</li>
    </ul>

    <h3>Artificial Intelligence</h3>
    <ul>
      <li>AI paradigms and areas: introduction to classical and modern approaches.</li>
      <li>Search algorithms: blind, informed, and local search; heuristics and evaluation functions; algorithms like A*.</li>
      <li>Knowledge representation: inference in propositional logic, first-order logic, and Bayesian networks.</li>
      <li>Planning and machine learning: planning techniques and essential algorithms.</li>
      <li>Problem modeling: specification of heuristics and parameterization of search algorithms.</li>
      <li>Logic programming: modeling and solving problems with Prolog.</li>
      <li>Inference in Bayesian networks: performing predictive and diagnostic inference.</li>
      <li>Machine learning: neural networks and inductive approaches to learning.</li>
    </ul>

    <h3>Computer Networks</h3>
    <ul>
      <li>Fundamentals of computer networks: terminology, organization, services, components, and structuring principles.</li>
      <li>Reliable data transmission: techniques like Stop & Wait, TCP, and FEC (Forward Error Correction).</li>
      <li>Quality of Service (QoS): techniques for improving and adapting to network traffic.</li>
      <li>Information diffusion: protocols like HTTP, scalability, and content distribution networks.</li>
      <li>Names and addresses: DNS, IP addresses, MAC, and their use in addressing layers.</li>
      <li>Routing: principles and algorithms, including DHCP, ARP, NAT, and IP routing.</li>
      <li>TCP/IP networks: architecture and essential protocols like DHCP, ARP, IP, and more.</li>
      <li>Switched Ethernet networks: operation of channels and statistical multiplexing.</li>
      <li>Network protocols and distributed applications: protocol development and performance analysis of distributed applications.</li>
    </ul>
  </div>
</section>
